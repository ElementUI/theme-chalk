@import "function";
@import "../common/var";

/* Break-points
 -------------------------- */
@mixin res($key, $map: $--breakpoints) {
  // 循环断点Map，如果存在则返回
  @if map-has-key($map, $key) {
    @media only screen and #{inspect(map-get($map, $key))} {
      @content;
    }
  } @else {
    @warn "Undefeined points: `#{$map}`";
  }
}

/* Scrollbar
 -------------------------- */
@mixin scroll-bar {
  $--scrollbar-thumb-background: #b4bccc;
  $--scrollbar-track-background: #fff;

  &::-webkit-scrollbar {
    z-index: 11;
    width: 6px;

    &:horizontal {
      height: 6px;
    }

    &-thumb {
      border-radius: 5px;
      width: 6px;
      background: $--scrollbar-thumb-background;
    }

    &-corner {
      background: $--scrollbar-track-background;
    }

    &-track {
      background: $--scrollbar-track-background;

      &-piece {
        background: $--scrollbar-track-background;
        width: 6px;
      }
    }
  }
}

/* Placeholder
 -------------------------- */
@mixin placeholder {
  &::-webkit-input-placeholder {
    @content;
  }

  &::-moz-placeholder {
    @content;
  }

  &:-ms-input-placeholder {
    @content;
  }
}

/* BEM
 -------------------------- */

$_BEM: (null, null, null);

@mixin b($block) {
  $lastBEM: $_BEM;
  $_BEM: ($block, null, null) !global;

  .#{$namespace}-#{$block} {
    @content;
  }

  $_BEM: $lastBEM !global;
}

@mixin e($elements) {
  $block: nth($_BEM, 1);

  @if null == $block {
    @error "Base-level rules cannot contain an element mixin";
  } @else {
    $selects: &;
    $old-elems: nth($_BEM, 2);

    @if (null != $old-elems) {
      $selects: ();

      @each $old-select in & {
        @each $old-element in $old-elems {
          $old-bem: ".#{$namespace}-#{$block}#{$element-separator}#{$old-element}";
          $old-len: length($old-select);

          @if nth($old-select, $old-len) == $old-bem {
            $selects: append($selects, set-nth($old-select, $old-len, ".#{$namespace}-#{$block}"), "comma", );
          } @else {
            $selects: append($selects, $old-select, "comma", );
          }
        }
      }
    }

    $lastBEM: $_BEM;
    $_BEM: ($block, $elements, null) !global;

    $parent: ".#{$namespace}-#{$block}";
    $current: ();

    @each $element in $elements {
      $current: append(
        $current,
        bem-extend($selects, $parent, "#{$parent}#{$element-separator}#{$element}"),
        "comma",
      );
    }

    @at-root {
      #{$current} {
        @content;
      }
    }

    $_BEM: $lastBEM !global;
  }
}

@mixin m($modifiers) {
  $block: nth($_BEM, 1);

  @if null == $block {
    @error "Base-level rules cannot contain a modifier mixin";
  } @else if null != nth($_BEM, 3) {
    @error "Modifier-level rules cannot contain another modifier mixin";
  } @else {
    $elements: nth($_BEM, 2);

    @if (null == $elements) {
      $elements: (null);
    }

    $lastBEM: $_BEM;
    $_BEM: ($block, $elements, $modifiers) !global;

    @each $element in $elements {
      $parent: ".#{$namespace}-#{$block}";

      @if (null != $element) {
        $parent: "#{$parent}#{$element-separator}#{$element}";
      }

      $current: ();

      @each $modifier in $modifiers {
        $current: append(
          $current,
          bem-extend(&, $parent, "#{$parent}#{$modifier-separator}#{$modifier}"),
          "comma",
        );
      }

      @at-root {
        #{$current} {
          @content;
        }
      }
    }

    $_BEM: $lastBEM !global;
  }
}

@mixin when($state) {
  @at-root {
    &.#{$state-prefix + $state} {
      @content;
    }
  }
}

@mixin extend-rule($name) {
  @extend #{'%shared-'+$name};
}

@mixin share-rule($name) {
  $rule-name: '%shared-'+$name;

  @at-root #{$rule-name} {
    @content;
  }
}

@mixin pseudo($pseudo) {
  @at-root #{&}#{':#{$pseudo}'} {
    @content;
  }
}
